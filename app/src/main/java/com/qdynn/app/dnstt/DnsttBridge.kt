package com.qdynn.app.dnstt

import android.util.Log
import java.lang.reflect.Method
import java.lang.reflect.Proxy

interface DnsttBridge {
    fun start(
        domain: String,
        password: String,
        dns: String,
        onPacketFromGo: (ByteArray) -> Unit,
        onLog: (String) -> Unit
    )

    fun sendPacket(packet: ByteArray)

    fun stop()
}

object DnsttBridgeFactory {
    fun create(): DnsttBridge {
        return try {
            // Try to load gomobile-generated classes reflectively.
            // If any of the expected classes are present, use reflective bridge.
            Class.forName("com.qdynn.dnstt.mobile.Bridge")
            GoDnsttBridgeReflective()
        } catch (_: Throwable) {
            try {
                Class.forName("com.qdynn.dnstt.mobile.Mobile")
                GoDnsttBridgeReflective()
            } catch (_: Throwable) {
                NoopDnsttBridge()
            }
        }
    }
}

private class NoopDnsttBridge : DnsttBridge {
    private var running = false
    private var logger: ((String) -> Unit)? = null

    override fun start(
        domain: String,
        password: String,
        dns: String,
        onPacketFromGo: (ByteArray) -> Unit,
        onLog: (String) -> Unit
    ) {
        running = true
        logger = onLog
        onLog("dnstt Noop start: domain=$domain dns=$dns")
    }

    override fun sendPacket(packet: ByteArray) {
        if (!running) return
        logger?.invoke("dnstt Noop sendPacket size=${packet.size}")
    }

    override fun stop() {
        if (!running) return
        running = false
        logger?.invoke("dnstt Noop stop")
    }
}

private class GoDnsttBridgeReflective : DnsttBridge {
    private var bridgeInstance: Any? = null
    private var methodStart: Method? = null
    private var methodSend: Method? = null
    private var methodStop: Method? = null

    override fun start(
        domain: String,
        password: String,
        dns: String,
        onPacketFromGo: (ByteArray) -> Unit,
        onLog: (String) -> Unit
    ) {
        // Resolve classes possibly generated by gomobile.
        // Prefer direct Bridge class; if constructor is absent, fall back to package factory method.
        val bridgeClass = try {
            Class.forName("com.qdynn.dnstt.mobile.Bridge")
        } catch (_: Throwable) {
            null
        }

        val packetHandlerIface = Class.forName("com.qdynn.dnstt.mobile.PacketHandler")
        val loggerIface = Class.forName("com.qdynn.dnstt.mobile.Logger")

        bridgeInstance = try {
            // Try no-arg constructor
            bridgeClass?.getDeclaredConstructor()?.newInstance()
        } catch (_: Throwable) {
            null
        }

        if (bridgeInstance == null) {
            // Try factory method on package class (Mobile.newBridge / Mobile.NewBridge)
            val packageClass = Class.forName("com.qdynn.dnstt.mobile.Mobile")
            val factoryMethod: Method? = try {
                packageClass.getMethod("newBridge")
            } catch (_: Throwable) {
                try { packageClass.getMethod("NewBridge") } catch (_: Throwable) { null }
            }
            bridgeInstance = factoryMethod?.invoke(null)
        }

        requireNotNull(bridgeInstance) { "Failed to instantiate Go Bridge" }

        val packetHandlerProxy = Proxy.newProxyInstance(
            packetHandlerIface.classLoader,
            arrayOf(packetHandlerIface)
        ) { _, method, args ->
            val name = method.name
            if ((name.equals("OnPacket", true) || name.equals("onPacket", true)) && args != null && args.isNotEmpty()) {
                val bytes = args[0] as ByteArray
                onPacketFromGo(bytes)
            }
            null
        }

        val loggerProxy = Proxy.newProxyInstance(
            loggerIface.classLoader,
            arrayOf(loggerIface)
        ) { _, method, args ->
            val name = method.name
            if ((name.equals("OnLog", true) || name.equals("onLog", true)) && args != null && args.isNotEmpty()) {
                val msg = args[0] as String
                onLog(msg)
            }
            null
        }

        val actualBridgeClass = bridgeInstance!!::class.java

        methodStart = try {
            actualBridgeClass.getMethod(
                "Start",
                String::class.java,
                String::class.java,
                String::class.java,
                packetHandlerIface,
                loggerIface
            )
        } catch (_: Throwable) {
            try {
                actualBridgeClass.getMethod(
                    "start",
                    String::class.java,
                    String::class.java,
                    String::class.java,
                    packetHandlerIface,
                    loggerIface
                )
            } catch (t: Throwable) {
                throw RuntimeException("Bridge Start method not found", t)
            }
        }

        methodSend = try {
            actualBridgeClass.getMethod("SendPacket", ByteArray::class.java)
        } catch (_: Throwable) {
            try { actualBridgeClass.getMethod("sendPacket", ByteArray::class.java) } catch (t: Throwable) {
                throw RuntimeException("Bridge SendPacket method not found", t)
            }
        }
        methodStop = try {
            actualBridgeClass.getMethod("Stop")
        } catch (_: Throwable) {
            try { actualBridgeClass.getMethod("stop") } catch (t: Throwable) {
                throw RuntimeException("Bridge Stop method not found", t)
            }
        }

        methodStart?.invoke(bridgeInstance, domain, password, dns, packetHandlerProxy, loggerProxy)
    }

    override fun sendPacket(packet: ByteArray) {
        try {
            methodSend?.invoke(bridgeInstance, packet)
        } catch (t: Throwable) {
            Log.w("GoDnsttBridge", "sendPacket failed", t)
        }
    }

    override fun stop() {
        try {
            methodStop?.invoke(bridgeInstance)
        } catch (_: Throwable) {
        } finally {
            bridgeInstance = null
        }
    }
} 